객체 지향 언어인 자비에서는 모든 사물을 단독으로 존재할 수 없다고 바라본다.
2가지 관점으로.
1) is a 관계 : 상속관계를 나타내는 말.
	ex) Duck is a Bird.
2) has a 관계 : 부품관계를 나타내는 말. 특정 객체가 다른 객체를 멤버변수로 보유한 경우를 말한다.
	ex) Car has a Wheel
	



1
아래의 (A)에서 Computer 클래스는 메모리에 올라갔으나, 부품으로 보유한 Ram, HardDisk 는 아직
메모리에 올라가지 못한 상태이다. (B)라인에 알맞는 코드를 작성하여 com의 부품도 메모리에 
올라가도록 처리하라.



class Computer{
    Ram ram;		// has a 관계
    HardDisk disk;	// has a 관계

    // 올바른 초기화 방법 : 생성자 활용
    public Computer(){
	ram = new Ram();
	disk = new HardDisk();
    }
}

class UseComputer{
    public static void main(String[] args){
      
         Computer  com=new Computer(); (A)

         (B)
    }
}

B에 들어갈 코드)
	com.ram = new Ram();
	com.disk = new HardDisk();
		이 방법은 무식한 방법이다. 생성자를 활용해 초기화 하는 것이 좋다.
		왜? 컴퓨터가 제조될 때, 부품도 같이 조립되어야 하니깐.


2
현실에 존재하는 모든 사물은 단독으로 존재할 수 없으며 여러 객체들로 구성된다. 
객체 지향 언어인 자바는 이러한 객체들 간의 관계를 크게 2가지로 보고 있는데, 이를 (    is a    )관계와  
(    has a    )관계라 한다.

아래의 경우에 해당되는 관계를 채워 넣으세요.
예를 들어, 볼펜은 스프링, 볼펜 심 , 플라스틱 몸체 등으로 이루어져 있다. 
자전거는 바퀴, 핸들, 체인 등 개별적 부품으로 구성되어 있다.
OOP에서는 이와 같이 특정 사물들을 부품으로 보유할 수 있는 관계를  (  has a  ) 관계라 한다.



3

빈 칸을 채우세요.
Ex)  오리 --------  새
(1) 한국인  --------- (  사람  )
(2) 승용차 -------- (  차  ) 
(3) 얼룩말  --------- (  말  )
(4) 손목시계 -------- (  시계  )
(5) 종이컵   -------- (  컵  )
(6) 운동화  --------- (  신발  )
(7) 외과,내과 의사 ---- (  의사  ) 
(8) 민법 -------------(  법  ) 
(9) 피아노 -------------(  악기  ) 
(10) 동화책 -------------(  책  )


4
현실의 자동차, 택시, 버스, 트럭을 자바 언어로 반영하되 재사용성을 고려해서 설계해 보세요
class Car{}
class Taxi extends Car{}
class Bus extends Car{}
class Truck extends Car{}


5
현실에 존재하는 객체들 중 상위 객체로부터 파생된 경우를 흔히 볼 수 있다. 
즉 자신보다 상위 개념의 객체가 존재하는 경우를 자바와 같은 OOP언어에서는 (   is a   ) 관계라 하며, extends 키워드로 표현한다.
이때 상위클래스를 부모클래스라 하며  (    super    )클래스라 하고, 자식클래스를 (     sub      ) 클래스라 한다.


6
다음 설명 중 올바른 것을 모두 고르면?
class Duck extends Bird{	// class Duck is a Bird. <- 하지만 이렇게 작성하는건 안된다. 개념일뿐.

}
(1) 새를 부모로 둔 오리 클래스를 정의한 것이다.
	( O )
(2) extends를 is a 로 해석해도 문장에 무리가 없다.
	( O )
(3) 클래스 선언을 Bird extends Duck 으로 순서를 바꾸어도 무리가 없다.
	( X ) 오리는 새다(참) / 새는 오리다(거짓). == 상속관계는 부모, 자식의 순서를 바꾸면 큰일난다.
(4) 이 클래스가 올바로 컴파일 되려면 먼저 Bird 클래스가 컴파일 되어 있어야 할 것이다.
	( O )
(5) Bird 를 부모클래스라 하며 자바에서는 parent 클래스 라고 표현한다.
	( X ) 자바뿐만 아니라 대부분의 객체지향 언어에서는 부모를 parent라고 하지 않는다.
		이 parent는 GUI프로그래밍 할 때, 컨테이너간 포함관계에서 바깥쪽 객체를 가리키는 용어로 쓰인다.
		html에서 div안에 img를 넣었다면 div를 parent라고 한다.
		그래서 앞으로 프로그래밍할 때, parent라는 말이 나오면 무조건, UI쪽 다루는구나 생각하면 된다.
(6) Duck 을 자식클래스라 하며 자바에서는 child 클래스 라고 표현한다.
	( X )



7
다음 설명 중 맞는 것은?
class Bird{
    String name=”그냥 새”;
    boolean fly=true;
    int legs=2;
}

// 오리클래스는 멤버변수 1개, 생성자 1개 이렇게 구성되어 있다.
class Duck extends Bird{
     String name=”오리”;
     public Duck(String  n){
         name=n;
     }
     public static void main(String[] args){
         name=”도날드”;         (가)
         Duck d=new Duck();   (나)
         d.name=”도날드”;      (다)
         d.fly=false;                (라)
     }
}
(1) (가)에서 Duck 클래스의 name 멤버변수의 값이 도날드로 바뀔 것이다.
	( X )
(2) (나) 에서 오리의 인스턴스가 1개 생성되어 heap 영역에 올라갈 것이다.
	( X ) 디폴트 생성자인 Duck()은 존재하지 않기 때문에 컴파일에러가 나서 인스턴스 생성이 불가하다.
(3) (나)에서 에러가 나지 않는다고 가정했을 때 (다)에서 name 변수값은 도날드로 변경될 것이다.
	( O )
(4) (라)의 문장은 제대로 수행될 것이다.
	( O ) fly가 자식에게 없지만, 부모의 것에 마음대로 접근할 수 있으므로, 값을 변경할 수 있다.
(추가질문) 현재 Duck 클래스의 생성자의 갯수는 몇개인가요?  ( 1개 )
	Duck() 클래스의 생성자는 1개이고, 부모의 생성자는 내 것이 아니므로 산입하면 안된다.
	중요한 것은 부모의 생성자는 물려받지 않는다는 점.
	왜? 
		생성자의 의미는 각 객체가 태어날 때, 자신의 개성을 만들어낼 수 있는 기회의 공간을 주고자 함이다.
		그런데  만일 부모의 생성자도 물려받는다면 그건 "부모의 자식"이 아니라 "부모의 복제인간"인 것이다.
		부모와 초기화가 같을 수는 없다. (부모님 자체가 되는 것이므로)
		생성 시점으로도 부모의 생성자를 마음대로 접근할 수 있다는 것도 상식적이지 않다.
		결론은) "부모의 생성자는 물려받지 않는다!!!!!."
			부모의 생성자는 "물려받는 것"이 아니라, 그저 "호출의 대상"일 뿐.
	특정 클래스의 멤버의 갯수를 말할 때는, 부모꺼를 말하는 게 아니라, 해당 클래스 안의 것들을 말하면 된다.
		물론 부모의 것에 접근할 수는 있지만..


8
다음 설명 중 올바르지 않은 것은?
(1) 상속이란 현실의 상,하위객체간의 관계를 OOP언어가 is a 관계로 표현한 기법이다.
	( O )
(2) 상속은 extends 키워드로 구현하며, extends 키워드를 is a 로 바꾸어 이해해도 된다.
	( O )
(3) 상속을 이용하면, 코드를 중복정의 하지 않아도 되며 개발시 재사용이 높아진다.
	( O )
(4) 부모클래스의 모든 것이 자식클래스에게 물려지지만, 생성자만은 자식 클래스에게 물려지지 않는다.
	( O )
(5) extends 키워드는 한 클래스내에서 여러 번 사용이 가능하며, 특별히 제한은 없다.
	( X ) 철수는 르브론의 아들이자 조던의 아들이다. -> 불가능하다.


9
다음 설명 중 올바르지 않은 것은?
(1)자식(sub)클래스는 상속을 통하여 부모(super)클래스의 멤버 변수 및 메서드를 물려받을 수 있다.
	( O )
(2)자식클래스가 보유한 변수와 메서드가 이미 부모클래스에도 동일한 명칭으로 존재할 경우, 상속을
    명시하는 자식이 보유한 변수와 메서드는 부모의 것으로 덮어써진다.
	( X )
(2) 상속을 이용하면, 객체가 일반적으로 갖는 공통성 있는 특징,기능들을 부모클래스에 정의하고, 
자식 클래스에서는 동일한 코드를 중복정의 하지 않아도 되므로, 개발시 소스의 재사용성이 높아진다.
	( O )
(3) 현실에서도 다중 상속이 존재하지 않듯, OOP언어에서도 다중 상속은 허용되지 않는다.
	( O ) 원칙은 그렇지만, 나중에 이건 해결할 수 있다.
(4) 부모클래스에서 멤버변수에 private 으로 접근 제한을 둘 경우, 이 멤버변수 조차도 자식이 접근할 수 있다.
	( X ) 상속 관계에서 접근가능한 것은 protected? 이다.
(5) 부모의 생성자가 상속되지 않는 이유는 생성자의 목적이 해당 객체가 태어날 때 그 객체만이 갖는 개성과
   스타일 등 해당 객체만이 가질 수 있는 유일한 초기화 작업을 지원하기 위함이므로, 생성자를 자식객체가 
물려받는다 하더라도, 사용할 의미가 없다고 보아야한다.
	( O ) 문제의 의도 : 부모 생성자가 상속되지 않는다.


10
아래 클래스에 대한 설명 중 맞는 것을 모두 고르면?
class Bird{
   String name=”새”;
   boolean fly;
   public Bird(Boolean f){
       fly=f;
}
}
class Duck extends Bird{
    String sound=”quack”;
}
class  UseTest{
public static void main(String[] args){
        Bird b=new Bird(); (가) 
        b.sound=”JJack JJack”; (나)
        Duck d=new Duck(); (다)
}
}
(1) (가)는 Bird 클래스를 메모리에 올리는 과정이므로 아무런 문제가 없다.
	( X ) 생성자의 매개변수 갯수가 맞지 않는다.
(2) (나)의 코드는 문제가 없이 실행될 것이다.
	( X ) sound변수는 부모에게 없다. 자식에게만 있다. 부모는 자식의 것에 접근하지 못한다.
(3) (다)의 코드는 Duck 클래스를 메모리에 올리는 과정이므로 아무런 문제가 없다.
	( X ) 부모의 생성자를 호출하는 때부터 에러가 난다.
(4) 자식클래스는 부모클래스의 name,fly 변수를 상속받는다.
	( O )
(5) 자식클래스는 부모클래스의 생성자를 상속받는다.
	( X ) 자식클래스는 생성될 때, 부모의 생성자를 "호출"할 뿐 절대 물려받지는 않는다.
(6) 현실과 마찬가지로, 자식보다 부모의 존재가 시점상 우선해야 하므로, 상속 관계에 있는 자식 클래스를 
메모리에 올리는 순간, 부모클래스의 인스턴스화 작업이 먼저 선행되어져야 한다.
	( O )


11
현실에 존재하는 여러 사물들은 단독적이기보다 서로 관계를 맺고 존재하는 경우가 대부분이다.
특히 OOP언어가 주목하고 있는 객체간의 관계는 2가지가 있는데, 하나는 객체간의 상,하위 관계를 
(    is a    )관계로 보고 (    extends     )키워드로 구현한다. 
또 다른 하나는 객체가 특정 객체들을 부품으로 보유하는 관계를 (   has a   )관계로 보고, 객체자료형을 
(   멤버변수   )로 보유하여 구현한다.


